<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <title>Document</title>
    <style>
        button.active {
            background: limegreen;
            font-weight: bold
        }

        canvas {
            border: 2px solid red;
        }
    </style>
    <!-- <script src="fabric.min.js"></script> -->
    <script src="https://unpkg.com/fabric@latest/dist/fabric.js"></script>
    <script src="https://unpkg.com/fabric@latest/src/mixins/eraser_brush.mixin.js"></script>
</head>

<body>
    <div class="controls">
        <button id="select" type="button" onclick="changeAction(this)">select</button>
        <button id="erase" type="button" onclick="changeAction(this)">erase</button>
        <button id="undo" type="button" onclick="changeAction(this)">undo erasing</button>
        <button id="draw" type="button" onclick="changeAction(this)">draw</button>
        <button id="spray" type="button" onclick="changeAction(this)">spray</button>
        <button id="rectangle" type="button" onclick="changeAction(this)">rectangle</button>
        <button id="circle" type="button" onclick="changeAction(this)">circle</button>
    </div>

    <div>
        <div>

            <label for="drawing-line-width">Line width:</label>
            <span class="info">30</span><input type="range" value="30" min="0" max="150" id="drawing-line-width"><br>
        </div>
        <div>
            <label for="drawing-color">Line color:</label>
            <input type="color" value="#005E7A" id="drawing-color"><br>
        </div>
        <div>
            <label for="a">
                background image <code>erasable</code>
            </label>
            <input id="a" type="checkbox" onchange="setBgImageErasableProp(this)">
        </div>
        <div>
            <label for="b">
                remove erased objects on <code>erasing:end</code>
            </label>
            <input id="b" type="checkbox" onchange="setErasingRemovesErasedObjects(this)">
        </div>
    </div>
    <div>
        <button type="button" onclick="toJSON()">toJSON</button>
        <button type="button" onclick="downloadImage()">to Image</button>
        <button type="button" onclick="downloadSVG()">toSVG</button>
        <button id="clear-canvas" class="btn btn-info">Clear</button><br>
        <label for="drawing-mode-selector">Mode:</label>
        <select id="drawing-mode-selector">
            <option>Pencil</option>
            <option>Circle</option>
            <option>Spray</option>
            <option>Pattern</option>
            <option>Marker</option>
            <option>Calligraphy</option>

            <option>hline</option>
            <option>vline</option>
            <option>square</option>
            <option>diamond</option>
            <option>texture</option>
        </select><br>
    </div>
    <div style="display:flex;flex-direction:row;">
        <div>
            <canvas id="c" width="500" height="620"></canvas>
        </div>
        <div style="margin:0 1rem;">
            <code>erasing:end</code><br>
            <code id="output">N/A</code>
        </div>
    </div>
    <script>
        var rect, isDown, origX, origY;
        const canvas = this.__canvas = new fabric.Canvas('c');
        setInterval(() => {

            var selectedObject = canvas.getActiveObject();
            if (selectedObject) {
                // An object is selected
                console.log(selectedObject);
            } else {
                // No object is selected
            }
        }, 1000);


        function onMouseDownRectangle(o) {
            console.log(selectedObject);
            isDown = true;
            var pointer = canvas.getPointer(o.e);
            origX = pointer.x;
            origY = pointer.y;
            var pointer = canvas.getPointer(o.e);
            canvas.isDrawingMode = false
            rect = new fabric.Rect({
                left: origX,
                top: origY,
                originX: 'left',
                originY: 'top',
                width: pointer.x - origX,
                height: pointer.y - origY,
                angle: 0,
                fill: 'rgba(255,0,0,0.5)',
                transparentCorners: false
            });
            canvas.add(rect);
        }

        function onMouseMoveRectangle(o) {
            if (!isDown) return;
            // cosoe
            var pointer = canvas.getPointer(o.e);
            canvas.isDrawingMode = false
            if (origX > pointer.x) {
                rect.set({ left: Math.abs(pointer.x) });
            }
            if (origY > pointer.y) {
                rect.set({ top: Math.abs(pointer.y) });
            }
            rect.set({ width: Math.abs(origX - pointer.x) });
            rect.set({ height: Math.abs(origY - pointer.y) });
            canvas.renderAll();
        }

        function onMouseUpRectangle(o) {
            isDown = false;
        }


        function onMouseDownCircle(o) {
            isDown = true;
            var pointer = canvas.getPointer(o.e);
            origX = pointer.x;
            origY = pointer.y;
            canvas.isDrawingMode = false;
            circle = new fabric.Circle({
                left: origX,
                top: origY,
                originX: 'left',
                originY: 'top',
                radius: pointer.x - origX,
                angle: 0,
                fill: '',
                stroke: 'red',
                strokeWidth: 3,
            });
            canvas.add(circle);
        }
        function onMouseMoveCircle(o) {
            if (!isDown) return;
            var pointer = canvas.getPointer(o.e);
            canvas.isDrawingMode = false;
            var radius = Math.max(Math.abs(origY - pointer.y), Math.abs(origX - pointer.x)) / 2;
            if (radius > circle.strokeWidth) {
                radius -= circle.strokeWidth / 2;
            }
            circle.set({ radius: radius });
            if (origX > pointer.x) {
                circle.set({ originX: 'right' });
            } else {
                circle.set({ originX: 'left' });
            }
            if (origY > pointer.y) {
                circle.set({ originY: 'bottom' });
            } else {
                circle.set({ originY: 'top' });
            }
            canvas.renderAll();
        }
        function onMouseUpCircle(o) {
            isDown = false;
            isDrawingMode = true;
        }
        let erasingRemovesErasedObjects = false;

        drawingLineWidthEl = document.getElementById('drawing-line-width')
        drawingLineWidthEl.onchange = function () {
            canvas.freeDrawingBrush.width = parseInt(this.value, 10) || 30;
            this.previousSibling.innerHTML = this.value;
        };

        drawingColorEl = document.getElementById('drawing-color')
        drawingColorEl.onchange = function () {
            var brush = canvas.freeDrawingBrush;
            brush.color = this.value;
            //   if (brush.getPatternSrc) {
            //     brush.source = brush.getPatternSrc.call(brush);
            //   }
        };

        clearEl = document.getElementById('clear-canvas');
        clearEl.onclick = function () { canvas.clear() };

        drawingOptionsEl = document.getElementById('drawing-mode-options'),
            document.getElementById('drawing-mode-selector').onchange = function () {

                if (this.value === 'hline') {
                    canvas.freeDrawingBrush = vLinePatternBrush;
                }
                else if (this.value === 'vline') {
                    canvas.freeDrawingBrush = hLinePatternBrush;
                }
                else if (this.value === 'square') {
                    canvas.freeDrawingBrush = squarePatternBrush;
                }
                else if (this.value === 'diamond') {
                    canvas.freeDrawingBrush = diamondPatternBrush;
                }
                else if (this.value === 'texture') {
                    canvas.freeDrawingBrush = texturePatternBrush;
                }
                // else if (this.value === 'Calligraphy') {
                //     // canvas.freeDrawingBrush = new fabric['calligraphyBrush'](canvas)
                //     const calligraphyBrush = new fabric.CalligraphyBrush(canvas);
                //     // calligraphyBrush.color = "#000000"; // set color to black
                //     calligraphyBrush.width = 5; // set stroke width to 5 pixels
                //     console.log(clicked)

                //     canvas.isDrawingMode = true;
                //     canvas.freeDrawingBrush = calligraphyBrush;
                // }
                else if (this.value === 'Marker') {
                    const markerBrush = new fabric.MarkerBrush(canvas);
                    markerBrush.color = "#000000"; // set color to black
                    markerBrush.width = 20; // set stroke width to 20 pixels
                    markerBrush.strokeLineCap = "round"; // set line cap to round

                    canvas.isDrawingMode = true;
                    canvas.freeDrawingBrush = markerBrush;
                }
                else {
                    console.log(this.value)
                    canvas.freeDrawingBrush = new fabric[this.value + 'Brush'](canvas);
                }

                if (canvas.freeDrawingBrush) {
                    var brush = canvas.freeDrawingBrush;
                    brush.color = drawingColorEl.value;
                    // if (brush.getPatternSrc) {
                    //     brush.source = brush.getPatternSrc.call(brush);
                    // }
                    brush.width = parseInt(drawingLineWidthEl.value, 10) || 1;
                    // brush.shadow = new fabric.Shadow({
                    //     blur: parseInt(drawingShadowWidth.value, 10) || 0,
                    //     offsetX: 0,
                    //     offsetY: 0,
                    //     affectStroke: true,
                    //     color: drawingShadowColorEl.value,
                    // });
                }
            };


        function changeAction(target) {
            // canvas.off('mouse:down', onMouseDownRectangle,onMouseDownCircle)
            // canvas.off('mouse:move', onMouseMoveRectangle,onMouseMoveCircle)
            // canvas.off('mouse:up', onMouseUpRectangle,onMouseUpCircle)

            canvas.off('mouse:down')
            canvas.off('mouse:move')
            canvas.off('mouse:up')
            const types = ['select', 'erase', 'undo', 'draw', 'spray', 'rectangle', 'circle']
            types.forEach(action => {
                const t = document.getElementById(action);
                t.classList.remove('active');
            });
            if (typeof target === 'string') target = document.getElementById(target);
            target.classList.add('active');
            switch (target.id) {
                case "select":
                    canvas.isDrawingMode = false;
                    break;
                case "fill":
                    canvas.isDrawingMode = false;

                    break;
                case "erase":
                    canvas.freeDrawingBrush = new fabric.EraserBrush(canvas);
                    canvas.freeDrawingBrush.width = 10;
                    canvas.isDrawingMode = true;
                    break;
                case "undo":
                    canvas.freeDrawingBrush = new fabric.EraserBrush(canvas);
                    canvas.freeDrawingBrush.width = 10;
                    canvas.freeDrawingBrush.inverted = true;
                    canvas.isDrawingMode = true;
                    break;
                case "draw":
                    canvas.freeDrawingBrush = new fabric.PencilBrush(canvas);
                    canvas.freeDrawingBrush.width = 35;
                    canvas.freeDrawingBrush.color = "green"
                    canvas.isDrawingMode = true;
                    break;
                case "spray":
                    canvas.freeDrawingBrush = new fabric.SprayBrush(canvas);
                    canvas.freeDrawingBrush.width = 35;
                    canvas.isDrawingMode = true;
                    break;
                case "circle":
                    canvas.on('mouse:down', onMouseDownCircle);
                    canvas.on('mouse:move', onMouseMoveCircle);
                    canvas.on('mouse:up', onMouseUpCircle);
                    canvas.isDrawingMode = true;
                    break;
                case "rectangle":
                    // var rect, isDown, origX, origY;
                    canvas.on('mouse:down', onMouseDownRectangle);
                    canvas.on('mouse:move', onMouseMoveRectangle);
                    canvas.on('mouse:up', onMouseUpRectangle);
                    function onObjectSelected(e) {
                        console.log(e.target.get('type'));
                    }
                    canvas.on('object:selected', onObjectSelected);

                    canvas.isDrawingMode = true;
                    break;
                default:
                    break;
            }
        }

        function init() {
            // canvas.setOverlayColor("rgba(0,255,255,0.4)", undefined, { erasable: false });
            const ctx = canvas.getContext("2d");
            ctx.fillStyle = "rgba(0, 0, 255, 0.5)";
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Set overlay blending mode
            ctx.globalCompositeOperation = "overlay";

            // Draw overlay shape
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const t = new fabric.Triangle({
                top: 300,
                left: 210,
                width: 100,
                height: 100,
                fill: "blue",
                erasable: false
            });

            canvas.add(
                new fabric.Rect({
                    top: 50,
                    left: 100,
                    width: 50,
                    height: 50,
                    fill: "#f55",
                    opacity: 0.8
                }),
                new fabric.Rect({
                    top: 50,
                    left: 150,
                    width: 50,
                    height: 50,
                    fill: "#f55",
                    opacity: 0.8
                }),
                new fabric.Group([
                    t,
                    new fabric.Circle({ top: 140, left: 230, radius: 75, fill: "green" })
                ], { erasable: 'deep' })
            );
            // fabric.Image.fromURL('https://ip.webmasterapi.com/api/imageproxy/http://fabricjs.com/assets/mononoke.jpg',
            //     function (img) {
            //         // img.set("erasable", false);
            //         img.scaleToWidth(480);
            //         img.clone((img) => {
            //             canvas.add(
            //                 img
            //                     .set({
            //                         left: 400,
            //                         top: 350,
            //                         clipPath: new fabric.Circle({
            //                             radius: 200,
            //                             originX: "center",
            //                             originY: "center"
            //                         }),
            //                         angle: 30
            //                     })
            //                     .scale(0.25)
            //             );
            //             canvas.renderAll();
            //         });

            //         img.set({ opacity: 0.7 });

            //         function animate() {
            //             img.animate("opacity", img.get("opacity") === 0.7 ? 0.4 : 0.7, {
            //                 duration: 1000,
            //                 onChange: canvas.renderAll.bind(canvas),
            //                 onComplete: animate
            //             });
            //         }

            //         animate();
            //         canvas.setBackgroundImage(img);
            //         img.set({ erasable: false });
            //         canvas.on("erasing:end", ({ targets, drawables }) => {
            //             var output = document.getElementById("output");
            //             output.innerHTML = JSON.stringify({
            //                 objects: targets.map((t) => t.type),
            //                 drawables: Object.keys(drawables)
            //             }, null, '\t');
            //             if (erasingRemovesErasedObjects) {
            //                 targets.forEach(obj => obj.group?.removeWithUpdate(obj) || canvas.remove(obj));
            //             }
            //         })
            //         canvas.renderAll();
            //     },
            //     { crossOrigin: "anonymous" }
            // );

            // function animate() {
            //     try {
            //         canvas
            //             .item(0)
            //             .animate("top", canvas.item(0).get("top") === 500 ? "100" : "500", {
            //                 duration: 1000,
            //                 onChange: canvas.renderAll.bind(canvas),
            //                 onComplete: animate
            //             });
            //     } catch (error) {
            //         setTimeout(animate, 500);
            //     }
            // }

            // animate();
        }

        const setDrawableErasableProp = (drawable, value) => {
            canvas.get(drawable)?.set({ erasable: value });
            changeAction('erase');
        };

        const setBgImageErasableProp = (input) =>
            setDrawableErasableProp("backgroundImage", input.checked);

        const setErasingRemovesErasedObjects = (input) =>
            (erasingRemovesErasedObjects = input.checked);

        const downloadImage = () => {
            const ext = "png";
            const base64 = canvas.toDataURL({
                format: ext,
                enableRetinaScaling: true
            });
            const link = document.createElement("a");
            link.href = base64;
            link.download = `eraser_example.${ext}`;
            link.click();
        };

        const downloadSVG = () => {
            const svg = canvas.toSVG();
            const a = document.createElement("a");
            const blob = new Blob([svg], { type: "image/svg+xml" });
            const blobURL = URL.createObjectURL(blob);
            a.href = blobURL;
            a.download = "eraser_example.svg";
            a.click();
            URL.revokeObjectURL(blobURL);
        };

        const toJSON = async () => {
            const json = canvas.toDatalessJSON(["clipPath", "eraser"]);
            const out = JSON.stringify(json, null, "\t");
            const blob = new Blob([out], { type: "text/plain" });
            const clipboardItemData = { [blob.type]: blob };
            try {
                navigator.clipboard &&
                    (await navigator.clipboard.write([
                        new ClipboardItem(clipboardItemData)
                    ]));
            } catch (error) {
                console.log(error);
            }
            const blobURL = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = blobURL;
            a.download = "eraser_example.json";
            a.click();
            URL.revokeObjectURL(blobURL);
        };
        init();
        changeAction('erase');

    </script>

</body>

</html>